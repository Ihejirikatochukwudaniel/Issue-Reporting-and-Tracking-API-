from pydantic import BaseModel, Field, EmailStr
from datetime import datetime
from typing import Optional
from app.models import IssueStatus, IssuePriority


class IssueBase(BaseModel):
    """
    Base schema with common fields.
    
    This is inherited by other schemas to avoid code duplication.
    Contains fields that are common to both creation and reading.
    """
    title: str = Field(
        ...,  # ... means required field
        min_length=1, 
        max_length=200,
        description="Brief title of the issue",
        examples=["Login button not working"]
    )
    description: Optional[str] = Field(
        None,  # None means optional
        description="Detailed description of the issue",
        examples=["When clicking the login button, nothing happens. No error message shown."]
    )
    status: IssueStatus = Field(
        default=IssueStatus.OPEN,
        description="Current status of the issue"
    )
    priority: IssuePriority = Field(
        default=IssuePriority.MEDIUM,
        description="Priority level"
    )
    reporter: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Name or email of the person reporting the issue",
        examples=["john.doe@example.com"]
    )
    assignee: Optional[str] = Field(
        None,
        max_length=100,
        description="Person assigned to resolve the issue",
        examples=["jane.smith@example.com"]
    )


class IssueCreate(IssueBase):
    """
    Schema for creating a new issue.
    
    Inherits all fields from IssueBase.
    Used when someone sends a POST request to create an issue.
    
    No 'id' or timestamp fields because:
    - id is auto-generated by database
    - timestamps are auto-set by database
    """
    pass


class IssueUpdate(BaseModel):
    """
    Schema for updating an existing issue.
    
    All fields are optional because:
    - Users might want to update only specific fields
    - Partial updates are common (PATCH request pattern)
    
    Example: User only wants to change status, not everything else.
    """
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = None
    status: Optional[IssueStatus] = None
    priority: Optional[IssuePriority] = None
    reporter: Optional[str] = Field(None, min_length=1, max_length=100)
    assignee: Optional[str] = Field(None, max_length=100)


class IssueResponse(IssueBase):
    """
    Schema for returning issue data to the user.
    
    Includes all the base fields PLUS:
    - id: So users know which issue they're looking at
    - timestamps: So users know when it was created/updated
    
    This is what gets sent back in API responses.
    """
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        """
        Pydantic configuration.
        
        from_attributes=True (formerly orm_mode):
        Tells Pydantic to also work with SQLAlchemy models, not just dicts.
        This allows: IssueResponse.from_orm(db_issue)
        """
        from_attributes = True


class IssueListResponse(BaseModel):
    """
    Schema for list responses with pagination info.
    
    Provides metadata about the list of issues:
    - How many total issues exist
    - How many are in this response
    - The actual issues
    
    This is good API design - gives users context about the data.
    """
    total: int = Field(description="Total number of issues")
    count: int = Field(description="Number of issues in this response")
    issues: list[IssueResponse] = Field(description="List of issues")


class MessageResponse(BaseModel):
    """
    Generic message response for operations like delete.
    
    Simple confirmation message for actions that don't return data.
    Example: After deleting an issue, confirm it was deleted.
    """
    message: str